# Современный CI/CD пайплайн для python микросервисов
<a href="https://pycon.ru/">![](https://badgen.net/badge/pycon/2022/?color=yellow)</a>

Этот репозиторий содержит примеры кода для моего доклада.

### Содержимое
* Полноценные куски CI/CD джоб (а точнее, шаблонов) вы можете посмотреть в файле [./jobs.yml](./jobs.yml). Конечно, там много специфики, но что-то из этого вам может пригодится.
* Вот тут можно посмотреть как можно полноценно устроить CD для helm + k8s [./helm-cd.yml](./helm-cd.yml) с поддержкой staging/production сред.
* Автоверсионирование с защитой от чистки вы можете посмотреть вот здесь [./scripts/auto-semver.py](./scripts/auto-semver.py)
* [./scripts/validate-gitlab-ci.py](./scripts/validate-gitlab-ci.py) Абсолютно неработоспособный скрипт, цель которого показать как вы можете запустив его внутри вашего центрального репозитория отвалидировать через сам gitlab собранные файлы. Вы должны отдать ваши template jobs и «публичный интерфейс» (или несколько) и отправить его в gitlab линтер. Это поможет вам проверить ваш пайплайн на базовую корректность и работоспособность.

### Возможности, на которые я делаю акцент
* `set -x` в начале пайплайна: даёт вам возможность видеть как запускаются ваши баш команды и значительно упрощают их отладку.
* `set -u` в `.vars-check-job` — штука, которая позволяет вам с помощью простого echo защитить свой пайплайн от отсутсвующих переменных. Установите флаг, распечатайте переменные и если каких-то из них нет, пайплайн упадёт.
* Двойная докеризация — собирайте в вашем пайплайне ваш образ с помощью `docker build`, [kaniko](https://github.com/GoogleContainerTools/kaniko) или [buildah](https://buildah.io/). В [./jobs.yml](./jobs.yml) пример с использованием buildah.
* Наследуйтесь от одной job'ы: потом проще ей задавать разные атрибуты, такие как interruptible или retry.
* Для множества микросервисов вам поможет централизация — сделать единый репозиторий и использовать пресеты. Т.е., например, вы используете текущий [./jobs.yml](./jobs.yml), а дальше пишете в `.gitlab-ci.yml` следующее:
    ```yaml
    include:
    - project: 'xfenix/pycon2022'
      file: 'public-example.yml'
    ```
    где:
    * xfenix/pycon2022 — путь к вашему репозиторию внутри вашего gitlab инстанса.
    * public-example.yml — «пресет», где вы собираете пайплайн из jobs.yml. Имеет смысл собрать несколько таких пресетов. У нас в проекте есть `python`, `python-postgres`, `pypi`, `pypi-poetry`, `docker-build`, `frontend`.
    * если вам нужен ещё более гранулярный контроль за составом пайплайна, подключайте не пресет, а jobs.yml напрямую.
* Если возможно, имеет смысл публичные переменные тоже собирать в пресеты. Например, у вас несколько репозиториев используют одинаковые не секретные переменные (username, docker registry address и прочее). Можно занести их в gitlab group vars, но они будут всегда «скрыты» (чтобы их посмотреть вам нужно будет зайти вглубь настроек gitlab проекта), а некоторым юзерам и вовсе недоступны, поэтому я и предлагаю положить их в файл. Пример: [./group-vars.yml](./group-vars.yml)
* Сборка образов в идеале должна предшествовать всем следующим шагам: сначала собираем образ, пушим его в удаленный registry, затем тестируем его, проводим статический анализ, а в конце скачиваем этот образ из registry, перетегиваем его и пушим с новым release тегом (характерным для вас) в удаленный registry. Смысл этого заключается в том, что в продакшн идут строго те образы, чьё окружение мы протестировали и статически проанализировали.
* Немного bash — не страшно!
* Шаблонные подстановки вроде `${VARIABLE:-default value}` очень помогают.
